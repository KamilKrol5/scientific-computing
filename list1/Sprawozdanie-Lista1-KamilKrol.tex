\documentclass[]{article}
\usepackage[utf8]{inputenc}
\usepackage{polski}
\usepackage{listings}
\usepackage[usenames,dvipsnames]{xcolor}
%%\hyphenchar\font=-1

\title{
	Sprawozdanie \\
	\large 
	Obliczenia naukowe - lista 1}
\author{Kamil Król}
\date{}

%% julia definition and coloring
\lstdefinelanguage{Julia}%
{morekeywords={abstract,break,case,catch,const,continue,do,else,elseif,%
		end,export,false,for,function,immutable,import,importall,if,in,%
		macro,module,otherwise,quote,return,switch,true,try,type,typealias,%
		using,while},%
	sensitive=true,%
	alsoother={$},%
	morecomment=[l]\#,%
	morecomment=[n]{\#=}{=\#},%
	morestring=[s]{"}{"},%
	morestring=[m]{'}{'},%
}[keywords,comments,strings]%

\lstset{%
	language         = Julia,
	basicstyle       = \ttfamily,
	keywordstyle     = \bfseries\color{blue},
	stringstyle      = \color{magenta},
	commentstyle     = \color{ForestGreen},
	showstringspaces = false,
}
%% end of julia definition and coloring

\begin{document}
	
	\maketitle
	
	\section{Zadanie 1}
	
	\subsection{MachEps}
	Epsilonem maszynowym macheps (ang. machine epsilon) nazywamy najmniejszą liczbę macheps większą od 0 taką, że fl(1.0 + macheps)\textgreater 1.0.
	
	W celu wyznaczenia metodą iteracyjną \textit{macheps} zgodnego z powyższą definicją napisałem program, a jego wyniki zamieściłem w poniższej tabeli. Zgodnie z treścią zadania program uruchomiłem dla typów Float16, Float32 oraz Float64 i porównałem z wartościami zwracanymi przez funkcję \textit{eps} dla każdego z typów.
	
	\begin{table}[h!]
		\centering
		\label{tab:table1}
		\begin{tabular}{|c|c|c|c|}
			\multicolumn{4}{c}{Iteracyjne wyznaczanie macheps}\\
			\hline
			& obliczony \textit{macheps} & eps(type) & wartość z pliku float.h \\
			\hline
			Float16 & 0.000977 & 0.000977 & xd \\
			\hline
			Float32 & 1.1920929e-7 & 1.1920929e-7 & xd \\
			\hline
			Float64 & 2.220446049250313e-16 & 2.220446049250313e-16 & xd \\
			\hline
		\end{tabular}
	\end{table}
	
	Okazało się, że wartości \textit{macheps} wyznaczone przeze mnie są równe wartościom zwracanym przez wbudowaną w język Julia funkcją \textit{eps}.
	
	W treści zadania pojawia się pytanie: jaki związek ma liczba \textit{macheps} z precyzją arytmetyki (oznaczaną na wykładzie przez $\epsilon$)? W celu odpowiedzi na to pytanie przytoczę najpierw definicję precyzji arytmetyki - $\epsilon$. Jest to największy błąd względny reprezentacji liczby jaki możemy popełnić i dla liczb reprezentowanych zgodnie ze standardem IEEE-754 wyraża się on wzorem: \(2^{-t}\). Podstawiając do wzoru dla arytmetyki Float32 mamy: \[\epsilon = 2^{-24} = 0.5 \cdot 2 ^{-23} = \frac{1}{2} \cdot \textit{macheps}\]
	Wartość \textit{macheps} dla Float32 w tabeli tj. 1.1920929e-7 jest zaokrąglona. Jej dokładna wartość wynosi: 1.1920928955078125e-7 co jest równe \(2 ^{-23}\) (stąd równość). \textit{Macheps} jest w komputerze przechowywany dokładnie.
	Wykonując to rozumowanie dla wszystkich typów widzimy zgodność i otrzymujemy zależność: \mbox{\(\textit{macheps} = 2\epsilon\)}.
	
	
	\subsection{Eta}
	Kolejnym zadaniem jest wyznaczenie liczby \textit{eta} takiej, że \textit{eta} \textgreater\space0.0 dla wszystkich typów zmiennopozycyjnych Float16, Float32, Float64.
	Wyniki napisanego przeze mnie programu, który iteracyjnie wyznacza te liczby, umieściłem w poniższej tabeli. Ponadto wartości otrzymanych liczb \textit{eta} porównałem z wartościami zwracanymi przez funkcje: \mbox{\textit{nextfloat}(Float16(0.0))}, \mbox{\textit{nextfloat}(Float32(0.0))}, \mbox{\textit{nextfloat}(Float64(0.0)}
	
	\begin{table}[h!]
		\centering
		\label{tab:table1}
		\begin{tabular}{|c|c|c|}
			\multicolumn{3}{c}{Iteracyjne wyznaczanie eta}\\
			\hline
			& obliczona \textit{eta} & nextfloat(type(0))  \\
			\hline
			Float16 & 6.0e-8 & 6.0e-8 \\
			\hline
			Float32 & 1.0e-45 & 1.0e-45 \\
			\hline
			Float64 & 5.0e-324 & 5.0e-324 \\
			\hline
		\end{tabular}
	\end{table}

	Wartości obliczone przeze mnie okazały się takie same jak zwrócone przez funkcje wbudowane w język Julia.
	Kolejnym pytaniem jest: Jaki związek ma liczba \textit{eta} z liczbą $MIN_{sub}$?\newline
	$MIN_{sub}$ jest najmniejszą liczbą zdenormalizowaną (subnormalną), tzn. taką gdzie cecha liczby jest wypełniona zerami. Inaczej najmniejsza możliwa do przechowania w danym systemie liczba. Liczba \textit{eta} jest równa liczbie $MIN_{sub}$, są one tożsame. Są to liczby tak małe, że nie da się ich pomniejszyć manipulując cechą.
	\colorbox{BurntOrange}{TO DO}\newline
	Innym pytaniem z treści zadania jest: co zwracają funkcje \textit{floatmin}(Float32) i \textit{floatmin}(Float64) i jaki jest związek zwracanych wartości z liczbą $MIN_{nor}$?\newline
		\colorbox{BurntOrange}{TO DO}
	Funkcje te zwracają najmniejsze liczby znormalizowane dla danego typu, a jest to dokładnie $MIN_{nor}$. Liczby znromalizowane to takie gdzie w mantysie zakładamy niepisaną jedynkę, tzn. wartość mantysy '0011...' oznacza '1.0011...' (inaczej niż w subnormalnych) i cecha nie jest zerem. Inaczej są to liczby, które można pomniejszyć zmniejszając wartość cechy.
	\subsection{Liczba MAX}
	Kolejnym zadaniem do zrobienia było wyznaczenie (iteracyjnie) liczby \textit{MAX} dla wszystkich typów zmiennopozycyjnych Float16, Float32, Float64 i porównanie wyników z wartościami zwracanymi przez funkcje:
	\mbox{\textit{floatmax}(Float16)}, \mbox{\textit{floatmax}(Float32)}, \mbox{\textit{floatmax}(Float64)} oraz z danymi zawartymi w pliku nagłówkowym float.h dowolnej instalacji języka C. Liczbę \textit{MAX} interpretuję jako największą wartość jaką można przechować w danym typie zmiennoprzecinkowym. Przy wyznaczaniu tej wartości musiałem pamiętać aby mantysa była wypełniona jedynkami. By to uzyskać postanowiłem wziąć liczbę \textit{zaraz przed} liczbą 2.0 czyli 2.0 - \textit{macheps}. Ten rezultat mogłem uzyskać też biorąc liczbę \textit{zaraz przed} 1.0, wtedy byłoby to \(1.0 - \frac{\textit{macheps}}{2}\).
	
	\begin{table}[h!]
		\centering
		\label{tab:table1}
		\begin{tabular}{|c|c|c|c|}
			\multicolumn{4}{c}{Iteracyjne wyznaczanie liczby \textit{MAX}}\\
			\hline
			& Obliczony \textit{MAX} & maxfloat(type) & wartość z pliku float.h \\
			\hline
			Float16 & 6.55e4 & 6.55e4 & xd \\
			\hline
			Float32 & 3.4028235e38 & 3.4028235e38 & xd \\
			\hline
			Float64 & 1.7976931348623157e308 & 1.7976931348623157e308 & xd \\
			\hline
		\end{tabular}
	\end{table}
	
	Ponownie wartości wyznaczone przeze mnie okazały się takie same jak te wyznaczone przez funkcje z języka Julia.
	
	\section{Zadanie 2}
	
	Zadanie to dotyczyło sprawdzenia eksperymentalnie w języku Julia
	słuszności tezy Kahana dla wszystkich typów zmiennopozycyjnych \mbox{Float16}, \mbox{Float32}, \mbox{Float64}. Wyniki programu zamieściłem w poniższej tabeli:
	\begin{table}[h!]
		\centering
		\label{tab:table1}
		\begin{tabular}{|c|c|c|}
			\multicolumn{3}{c}{}\\
			\hline
			& Obliczony eps wg. wzoru Kahana & Wartość funkcji eps(type)\\
			\hline
			Float16 & -2.220446049250313e-16 & 2.220446049250313e-16 \\
			\hline
			Float32 & 1.1920929e-7 & 1.1920929e-7\\
			\hline
			Float64 &-2.220446049250313e-16 &2.220446049250313e-16\\
			\hline
		\end{tabular}
	\end{table}
	
	Ponadto mój program sprawdzał, czy wartości bezwzględne otrzymanych eps są równe i okazało się że tak jest. Wnioskiem z doświadczenia jest to, że teza Kahana jest słuszna - macheps można obliczyć stosując zaproponowany przez niego wzór. W celu otrzymania macheps należy na wynik otrzymany ze wzoru \(3(4/3-1)-1\) nałożyć wartość bezwzględną. 
	
	\section{Zadanie 3} 
	
	Celem tego zadania było eksperymentalne sprawdzenie, że w arytmetyce \mbox{Float64} liczby zmiennopozycyjne są równomiernie rozmieszczone w [1, 2] z
	krokiem \(\delta = 2^{-52}\).
	Mój program zaczynał od liczby 1.0 i z każdą iteracją dodawał do niej liczbę $\delta$. W celu zidentyfikowania czy wybrany krok jest poprawny drukowałem kolejne wartości liczb i obserwowałem jak się zmieniają. Rezultaty w tabeli poniżej. 
	
		\begin{table}[h!]
		\centering
		\label{tab:table1}
		\begin{tabular}{|c|c|}
			\multicolumn{2}{c}{} \\
			\hline
			& bitowa reprezentacja \\
			\hline
			$1.0 + 1\delta$ & 0|01111111111|0000000000000000000000000000000000000000000000000001 \\
			\hline                    
			$1.0 + 2\delta$ & 0|01111111111|0000000000000000000000000000000000000000000000000010 \\
			\hline                    
			$1.0 + 3\delta$ & 0|01111111111|0000000000000000000000000000000000000000000000000011 \\
			\hline             
			$1.0 + 4\delta$ & 0|01111111111|0000000000000000000000000000000000000000000000000100 \\
			\hline             
			$1.0 + 5\delta$ & 0|01111111111|0000000000000000000000000000000000000000000000000101 \\
			\hline             
			$1.0 + 6\delta$ & 0|01111111111|0000000000000000000000000000000000000000000000000110 \\
			\hline             
			$1.0 + 7\delta$ & 0|01111111111|0000000000000000000000000000000000000000000000000111 \\
			\hline             
			$1.0 + 8\delta$ & 0|01111111111|0000000000000000000000000000000000000000000000001000 \\
			\hline             
		%%	$1.0 + 9\delta$ & 0|01111111111|0000000000000000000000000000000000000000000000001001 \\
		%%	\hline
			... & ... \\
			\hline
		\end{tabular}
	\end{table}

	Widać w kolejnych rekordach, że wybrany krok - $\delta$ jest poprawny (dla przedziału [1,2]), ponieważ wartości zmieniają się na najmniej znaczących bitach (na końcu) w sposób umożliwiający przejście przez wszystkie możliwe wartości mantysy. \newline 
	Pojawia się pytanie: Jak rozmieszczone są liczby zmiennopozycyjne w przedziale \([\frac{1}{2},1]\), a jak w przedziale \mbox{[2, 4]} i jak
	mogą być przedstawione dla rozpatrywanego przedziału? \newline
	Liczbę $\delta$ dla przedziału \([\frac{1}{2},1]\) będziemy nazywać $\delta_1$, a dla \mbox{[2, 4]}  $\delta_4$. Liczb we wszystkich trzech wspomianych przedziałach jest tyle samo (w tej reprezentacji). Np. między 1 i 2 jest tyle samo liczb co między 2 i 4, a tych jest tyle samo co w przedziale [4,8] itd. Granicami tych przedziałów są potęgi liczby 2. Jak można z tą wiedzą wyznaczyć $\delta$ dla przedziałów  \([\frac{1}{2},1]\) \mbox{i [2, 4]?} Wiemy, że $\delta$ dla przedziału [1,2] wynosi \(\delta = 2^{-52}\). Długość przedziału \([\frac{1}{2},1]\) jest 2 razy mniejsza od długości [1,2], więc naturalnym kandydatem dla liczby $\delta_1$ (dla przedziału \([\frac{1}{2},1]\)) wydaje się liczba $\delta$ podzielona przez 2. Zatem mamy \(\delta_1 = 2^{-53}\). \newline 
	Przedział \mbox{[2, 4]} ma długość dwa razy większą niż \mbox{[1, 2]}, więc kandydatem na liczbę $\delta_4$ będzie liczba 2 razy więszka od $\delta$. W związku z tym mamy \(\delta_4 = 2^{-51}\).
	Pozostaje te wartości eksperymentalnie sprawdzić. W poniższej tabeli znajdują się wyniki programu, który sprawdza liczby $\delta_1$ i $\delta_4$ w analogiczny sposób jak przy sprawdzaniu $\delta$ dla przedziału \mbox{[1,2]}.
	
	\begin{table}[h!]
	\centering
	\label{tab:table1}
		\begin{tabular}{|c|c|}
			\multicolumn{2}{c}{\(\delta_1 = 2^{-53}\)} \\
			\hline
			& bitowa reprezentacja \\
			\hline
			$0.5 + 1\delta$ &  0|01111111110|0000000000000000000000000000000000000000000000000001 \\ \hline
			$0.5 + 2\delta$ &  0|01111111110|0000000000000000000000000000000000000000000000000010 \\ \hline
			$0.5 + 3\delta$ &  0|01111111110|0000000000000000000000000000000000000000000000000011 \\ \hline
			$0.5 + 4\delta$ &  0|01111111110|0000000000000000000000000000000000000000000000000100 \\ \hline
			$0.5 + 5\delta$ &  0|01111111110|0000000000000000000000000000000000000000000000000101 \\ \hline
			$0.5 + 6\delta$ &  0|01111111110|0000000000000000000000000000000000000000000000000110 \\ \hline
			$0.5 + 7\delta$ &  0|01111111110|0000000000000000000000000000000000000000000000000111 \\ \hline
			$0.5 + 8\delta$ &  0|01111111110|0000000000000000000000000000000000000000000000001000 \\ \hline
			$0.5 + 9\delta$ &  0|01111111110|0000000000000000000000000000000000000000000000001001 \\ \hline
		\end{tabular}
	\end{table}
	\begin{table}[h!]
		\centering
		\label{tab:table1}
			\begin{tabular}{|c|c|}
			\multicolumn{2}{c}{\(\delta_4 = 2^{-51}\)} \\
			\hline
			& bitowa reprezentacja \\
			\hline
			$2.0 + 1\delta$ &  0|10000000000|0000000000000000000000000000000000000000000000000001 \\ \hline
			$2.0 + 2\delta$ &  0|10000000000|0000000000000000000000000000000000000000000000000010 \\ \hline
			$2.0 + 3\delta$ &  0|10000000000|0000000000000000000000000000000000000000000000000011 \\ \hline
			$2.0 + 4\delta$ &  0|10000000000|0000000000000000000000000000000000000000000000000100 \\ \hline
			$2.0 + 5\delta$ &  0|10000000000|0000000000000000000000000000000000000000000000000101 \\ \hline
			$2.0 + 6\delta$ &  0|10000000000|0000000000000000000000000000000000000000000000000110 \\ \hline
			$2.0 + 7\delta$ &  0|10000000000|0000000000000000000000000000000000000000000000000111 \\ \hline
			$2.0 + 8\delta$ &  0|10000000000|0000000000000000000000000000000000000000000000001000 \\ \hline
			$2.0 + 9\delta$ &  0|10000000000|0000000000000000000000000000000000000000000000001001 \\ \hline
		\end{tabular}
	\end{table}

	Widać, że wartości $\delta_1$ i $\delta_4$ są poprawne z tego samego powodu co poprzednio - wartości zmieniają się na najmniej znaczących bitach (na końcu) w sposób umożliwiający przejście przez wszystkie możliwe wartości mantysy.
	
	\section{Zadanie 4}

	Celem tego zadania było eksperymentalne znalezienie w arytmetyce Float64 (double) najmniejszej liczby zmiennopozycyjnej x w przedziale (1,2) takiej, że \(x \cdot \frac{1}{x} \neq 1\). 
	Wynik mojego programu to: 1.000000057228997. Reprezentacja tej liczby w arytmetyce Float64 to: \newline 
	\mbox{0 01111111111 0000000000000000000000001111010111001011111100101010}.\newline
	\colorbox{BurntOrange}{TO DO} Wnioski?\newline
	
	
	\section{Second Section}
	
	Lorem ipsum dolor sit amet, consectetuer adipiscing elit.  
	Etiam lobortis facilisissem.  Nullam nec mi et neque pharetra 
	sollicitudin.  Praesent imperdiet mi necante...
	
\end{document}